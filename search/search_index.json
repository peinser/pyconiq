{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Unofficial Python package to interface with the payment processor Payconiq.</p>"},{"location":"#introduction","title":"Introduction","text":""},{"location":"#installation","title":"Installation","text":"<p>Once the project cloned or the codespace ready, you can install the project dependencies. For development, you can use the <code>dev</code> extra to install the development dependencies.</p> <pre><code>poetry install --with=dev\n</code></pre> <p>or using pip:</p> <pre><code>pip install -e .[dev]\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pyconiq<ul> <li>__version__</li> <li>concepts</li> <li>constants</li> <li>exceptions</li> <li>integrations<ul> <li>base</li> <li>static</li> </ul> </li> <li>qr</li> </ul> </li> </ul>"},{"location":"reference/pyconiq/","title":"pyconiq","text":"<p>pyconiq: an unofficial Python package to interface with the payment processor Payconiq.</p>"},{"location":"reference/pyconiq/__version__/","title":"__version__","text":"<p>Returns the current version of the <code>pyconiq</code> module through the <code>__version__</code> variable.</p>"},{"location":"reference/pyconiq/concepts/","title":"concepts","text":"<p>A set of base concepts used throughout <code>pyconiq</code> and utility functions to allocate them.</p>"},{"location":"reference/pyconiq/constants/","title":"constants","text":"<p>A set of final variables that are constant with respect to the runtime of the program executing this module. All constants have default values, which can be <code>None</code>.</p> <p>Constants:</p> <p>PYCONIQ_DEFAULT_MERCHANT     Holds the default merchant identifier to be used within <code>pyconiq</code>. If no such     environment variable is specified, it's default value will be None.</p> <p>PYCONIQ_BASE     The base endpoint to use when interacting with Payconiq's servers. If no     environment variable is specified, it's default value is <code>https://payconiq.com</code>.</p> <p>PYCONIQ_API_KEY_STATIC   PYCONIQ_API_KEY_INVOICE   PYCONIQ_API_KEY_RECEIPT   PYCONIQ_API_KEY_APP2APP     Default API keys that will be used in the corresponding intergrations. If the     environment variable has not been provided, the respective default will be <code>None</code>.</p>"},{"location":"reference/pyconiq/exceptions/","title":"exceptions","text":"<p>Specific exceptions tied to <code>pyconiq</code>.</p>"},{"location":"reference/pyconiq/qr/","title":"qr","text":""},{"location":"reference/pyconiq/qr/#pyconiq.qr.static","title":"<code>static(pos, integration, border=1, box_size=10, error_correction=qrcode.constants.ERROR_CORRECT_L)</code>","text":"<p>Generates a static QR code for the Payconiq Instore (v3) API integrations. These QR codes are integrated close to the point of sale. In fact, they are inherently tied to the location and specifically identifiers the point of sale.</p> Source code in <code>src/pyconiq/qr.py</code> <pre><code>def static(\n    pos: str,\n    integration: BaseIntegration,\n    border: int = 1,\n    box_size: int = 10,\n    error_correction: int = qrcode.constants.ERROR_CORRECT_L,\n) -&gt; qrcode.QRCode:\n    r\"\"\"\n    Generates a static QR code for the Payconiq Instore (v3) API integrations. These\n    QR codes are integrated close to the point of sale. In fact, they are inherently\n    tied to the location and specifically identifiers the point of sale.\n    \"\"\"\n    assert pos is not None and integration is not None\n\n    # Generate the data that we are going to encode in the QR code.\n    data = f\"{PYCONIQ_BASE}/l/1/{integration.profile}/{pos}\".upper()\n\n    # Generate the actual QR code.\n    qr = qrcode.QRCode(\n        version=1,\n        error_correction=error_correction,\n        box_size=box_size,\n        border=border,\n    )\n\n    qr.add_data(data)\n    qr.make(fit=True)\n\n    return qr\n</code></pre>"},{"location":"reference/pyconiq/integrations/","title":"integrations","text":""},{"location":"reference/pyconiq/integrations/base/","title":"base","text":"<p>Abstract definition of a Payconiq integration.</p>"},{"location":"reference/pyconiq/integrations/base/#pyconiq.integrations.base.BaseIntegration","title":"<code>BaseIntegration</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>src/pyconiq/integrations/base.py</code> <pre><code>class BaseIntegration(ABC):\n    def __init__(\n        self,\n        merchant: Merchant,\n        profile: str,\n        key: str,\n        base: str,\n    ):\n        super().__init__()\n        self._base = base\n        self._merchant = merchant\n        self._profile = profile\n        self._key = key\n\n    @functools.cached_property\n    def _headers(self) -&gt; dict[str, str]:\n        return {\"Authorization\": f\"Bearer {self._key}\"}\n\n    def _handle_api_error(\n        self,\n        status: int,\n        payload: dict[str, Any],\n        transaction: Transaction | str,\n    ) -&gt; None:\n        r\"\"\"\n        Procedure that handles the specified HTTP error given a certain transaction\n        or transaction identifier. Calling this method will always throw an exception.\n        In particular, this is an internal method that will be called whenever an\n        API error has been detected.\n        \"\"\"\n        match status:\n            case HTTPStatus.UNAUTHORIZED:\n                raise UnauthorizedError(payload, self)\n            case HTTPStatus.FORBIDDEN:\n                raise ForbiddenTransactionError(payload, self)\n            case HTTPStatus.NOT_FOUND:\n                raise UnknownTransactionError(payload, transaction)\n            case HTTPStatus.TOO_MANY_REQUESTS:\n                raise RateLimitError(payload)\n            case HTTPStatus.INTERNAL_SERVER_ERROR:\n                raise PayconiqTechnicalError(payload)\n            case HTTPStatus.SERVICE_UNAVAILABLE:\n                raise PayconiqUnavailableError(payload)\n            case _:\n                raise Exception(payload)\n\n    async def _transaction_state(self, transaction: str) -&gt; dict[str, Any]:\n        r\"\"\"\n        Fetches a state object from Payconiq based on the provided transaction\n        identifier. If any error occurs, one of the common `pyconiq` exceptions\n        will be thrown. In particular, those defined in `_handle_api_error`.\n        \"\"\"\n        assert transaction is not None and isinstance(transaction, str)\n\n        async with aiohttp.ClientSession() as session, session.get(\n            url=f\"{self._base}/v3/payments/{transaction}\",\n            headers=self._headers,\n        ) as response:\n            payload = await response.json()\n            if not response.ok:\n                self._handle_api_error(\n                    status=response.status,\n                    payload=payload,\n                    transaction=transaction,\n                )\n                # Note, this line won't be reached as an exception will be thrown.\n\n            return payload\n\n    @property\n    def base(self) -&gt; str:\n        return self._base\n\n    @property\n    def merchant(self) -&gt; Merchant:\n        return self._merchant\n\n    @property\n    def profile(self) -&gt; str:\n        return self._profile\n\n    @abstractmethod\n    async def cancel(self, transaction: Transaction) -&gt; None:\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create(self, *args: Any, **kwargs: Any) -&gt; Transaction:\n        raise NotImplementedError\n\n    async def update(\n        self,\n        transaction: Transaction,\n    ) -&gt; None:\n        r\"\"\"\n        Synchronizes the state of the specified transaction with Payconiq. Note that,\n        if any API error occurs, an exception will be thrown corresponding to the\n        API error of interest.\n        \"\"\"\n        transaction.state = await self._transaction_state(transaction.id)\n\n    async def details(\n        self,\n        transaction: str,\n    ) -&gt; Transaction:\n        r\"\"\"\n        Fetches a transactions based on the specified transaction or payment identifier.\n        \"\"\"\n        return Transaction(\n            integration=self,\n            **await self._transaction_state(transaction),\n        )\n</code></pre>"},{"location":"reference/pyconiq/integrations/base/#pyconiq.integrations.base.BaseIntegration.details","title":"<code>details(transaction)</code>  <code>async</code>","text":"<p>Fetches a transactions based on the specified transaction or payment identifier.</p> Source code in <code>src/pyconiq/integrations/base.py</code> <pre><code>async def details(\n    self,\n    transaction: str,\n) -&gt; Transaction:\n    r\"\"\"\n    Fetches a transactions based on the specified transaction or payment identifier.\n    \"\"\"\n    return Transaction(\n        integration=self,\n        **await self._transaction_state(transaction),\n    )\n</code></pre>"},{"location":"reference/pyconiq/integrations/base/#pyconiq.integrations.base.BaseIntegration.update","title":"<code>update(transaction)</code>  <code>async</code>","text":"<p>Synchronizes the state of the specified transaction with Payconiq. Note that, if any API error occurs, an exception will be thrown corresponding to the API error of interest.</p> Source code in <code>src/pyconiq/integrations/base.py</code> <pre><code>async def update(\n    self,\n    transaction: Transaction,\n) -&gt; None:\n    r\"\"\"\n    Synchronizes the state of the specified transaction with Payconiq. Note that,\n    if any API error occurs, an exception will be thrown corresponding to the\n    API error of interest.\n    \"\"\"\n    transaction.state = await self._transaction_state(transaction.id)\n</code></pre>"},{"location":"reference/pyconiq/integrations/base/#pyconiq.integrations.base.TransactionLinks","title":"<code>TransactionLinks</code>  <code>dataclass</code>","text":"Source code in <code>src/pyconiq/integrations/base.py</code> <pre><code>@dataclass\nclass TransactionLinks:\n    cancel: str | None\n    deeplink: str | None\n    self: str | None\n    qr: str | None\n\n    KEY_LINKS: Final = \"_links\"\n    KEY_CANCEL: Final = \"cancel\"\n    KEY_DEEPLINK: Final = \"deeplink\"\n    KEY_SELF: Final = \"self\"\n    KEY_QR: Final = \"qrcode\"\n    KEY_HREF: Final = \"href\"\n\n    @staticmethod\n    def parse(state: dict[str, Any]) -&gt; TransactionLinks:\n        r\"\"\"\n        Utility method that parses the specified transaction state into a\n        TransactionLinks data class for easy link accessability.\n        \"\"\"\n        links = state.get(TransactionLinks.KEY_LINKS, {})\n\n        cancel = links.get(TransactionLinks.KEY_CANCEL, {}).get(\n            TransactionLinks.KEY_HREF, None\n        )\n\n        deeplink = links.get(TransactionLinks.KEY_DEEPLINK, {}).get(\n            TransactionLinks.KEY_HREF, None\n        )\n\n        self = links.get(TransactionLinks.KEY_SELF, {}).get(\n            TransactionLinks.KEY_HREF, None\n        )\n\n        qr = links.get(TransactionLinks.KEY_QR, {}).get(TransactionLinks.KEY_HREF, None)\n\n        return TransactionLinks(\n            cancel=cancel,\n            deeplink=deeplink,\n            self=self,\n            qr=qr,\n        )\n</code></pre>"},{"location":"reference/pyconiq/integrations/base/#pyconiq.integrations.base.TransactionLinks.parse","title":"<code>parse(state)</code>  <code>staticmethod</code>","text":"<p>Utility method that parses the specified transaction state into a TransactionLinks data class for easy link accessability.</p> Source code in <code>src/pyconiq/integrations/base.py</code> <pre><code>@staticmethod\ndef parse(state: dict[str, Any]) -&gt; TransactionLinks:\n    r\"\"\"\n    Utility method that parses the specified transaction state into a\n    TransactionLinks data class for easy link accessability.\n    \"\"\"\n    links = state.get(TransactionLinks.KEY_LINKS, {})\n\n    cancel = links.get(TransactionLinks.KEY_CANCEL, {}).get(\n        TransactionLinks.KEY_HREF, None\n    )\n\n    deeplink = links.get(TransactionLinks.KEY_DEEPLINK, {}).get(\n        TransactionLinks.KEY_HREF, None\n    )\n\n    self = links.get(TransactionLinks.KEY_SELF, {}).get(\n        TransactionLinks.KEY_HREF, None\n    )\n\n    qr = links.get(TransactionLinks.KEY_QR, {}).get(TransactionLinks.KEY_HREF, None)\n\n    return TransactionLinks(\n        cancel=cancel,\n        deeplink=deeplink,\n        self=self,\n        qr=qr,\n    )\n</code></pre>"},{"location":"reference/pyconiq/integrations/base/#pyconiq.integrations.base.TransactionStatus","title":"<code>TransactionStatus</code>","text":"<p>             Bases: <code>StrEnum</code></p> Source code in <code>src/pyconiq/integrations/base.py</code> <pre><code>class TransactionStatus(StrEnum):\n    AUTHORIZATION_FAILED: Final = \"AUTHORIZATION_FAILED\"\n    AUTHORIZED: Final = \"AUTHORIZED\"\n    CANCELLED: Final = \"CANCELLED\"\n    EXPIRED: Final = \"EXPIRED\"\n    FAILED: Final = \"FAILED\"\n    IDENTIFIED: Final = \"IDENTIFIED\"\n    PENDING: Final = \"PENDING\"\n    SUCCEEDED: Final = \"SUCCEEDED\"\n\n    @staticmethod\n    def terminal(value: TransactionStatus) -&gt; bool:\n        r\"\"\"\n        Indicates whether a transaction state carries the mark `terminal`. A\n        transaction marked `terminal` implies that the transaction does not\n        changes state. That is, the state is final.\n        \"\"\"\n        return value in {\n            TransactionStatus.CANCELLED,\n            TransactionStatus.EXPIRED,\n            TransactionStatus.FAILED,\n            TransactionStatus.SUCCEEDED,\n        }\n\n    @staticmethod\n    def parse(state: dict[str, Any]) -&gt; TransactionStatus:\n        r\"\"\"\n        Returns a TransactionStatus instance based on the raw state of a Transaction.\n        \"\"\"\n        status = state.get(\"status\", None)\n\n        assert status is not None\n\n        status = status.upper()\n\n        if status not in TransactionStatus:\n            raise UnknownTransactionStatusError(\n                f\"{status} is not a valid transaction status.\"\n            )\n\n        return TransactionStatus[status]\n</code></pre>"},{"location":"reference/pyconiq/integrations/base/#pyconiq.integrations.base.TransactionStatus.parse","title":"<code>parse(state)</code>  <code>staticmethod</code>","text":"<p>Returns a TransactionStatus instance based on the raw state of a Transaction.</p> Source code in <code>src/pyconiq/integrations/base.py</code> <pre><code>@staticmethod\ndef parse(state: dict[str, Any]) -&gt; TransactionStatus:\n    r\"\"\"\n    Returns a TransactionStatus instance based on the raw state of a Transaction.\n    \"\"\"\n    status = state.get(\"status\", None)\n\n    assert status is not None\n\n    status = status.upper()\n\n    if status not in TransactionStatus:\n        raise UnknownTransactionStatusError(\n            f\"{status} is not a valid transaction status.\"\n        )\n\n    return TransactionStatus[status]\n</code></pre>"},{"location":"reference/pyconiq/integrations/base/#pyconiq.integrations.base.TransactionStatus.terminal","title":"<code>terminal(value)</code>  <code>staticmethod</code>","text":"<p>Indicates whether a transaction state carries the mark <code>terminal</code>. A transaction marked <code>terminal</code> implies that the transaction does not changes state. That is, the state is final.</p> Source code in <code>src/pyconiq/integrations/base.py</code> <pre><code>@staticmethod\ndef terminal(value: TransactionStatus) -&gt; bool:\n    r\"\"\"\n    Indicates whether a transaction state carries the mark `terminal`. A\n    transaction marked `terminal` implies that the transaction does not\n    changes state. That is, the state is final.\n    \"\"\"\n    return value in {\n        TransactionStatus.CANCELLED,\n        TransactionStatus.EXPIRED,\n        TransactionStatus.FAILED,\n        TransactionStatus.SUCCEEDED,\n    }\n</code></pre>"},{"location":"reference/pyconiq/integrations/static/","title":"static","text":""},{"location":"reference/pyconiq/integrations/static/#pyconiq.integrations.static.StaticIntegration","title":"<code>StaticIntegration</code>","text":"<p>             Bases: <code>BaseIntegration</code></p> Source code in <code>src/pyconiq/integrations/static.py</code> <pre><code>class StaticIntegration(BaseIntegration):\n    def __init__(\n        self,\n        merchant: Merchant,\n        profile: str | None = PAYCONIQ_PAYMENT_PROFILE_STATIC,\n        key: str | None = PYCONIQ_API_KEY_STATIC,\n        base: str = PYCONIQ_API_BASE,\n        callback: str | None = None,\n    ) -&gt; None:\n        assert profile is not None and key is not None\n        super().__init__(\n            merchant=merchant,\n            profile=profile,\n            key=key,\n            base=base,\n        )\n\n        self._callback = callback\n\n    @property\n    def callback(self) -&gt; str | None:\n        return self._callback\n\n    async def cancel(\n        self,\n        transaction: Transaction,\n    ) -&gt; None:\n        r\"\"\"\n        Cancels the specified transaction.\n\n        Returns True on success, `False` otherwise.\n        \"\"\"\n        endpoint = transaction.links.cancel\n        assert endpoint is not None\n\n        async with aiohttp.ClientSession() as session, session.delete(\n            url=endpoint,\n            headers=self._headers,\n        ) as response:\n            if not response.ok:\n                status = response.status\n                self._handle_api_error(\n                    status=status,\n                    payload=await response.json(),\n                    transaction=transaction,\n                )\n                # Note, this line won't be reached as an exception will be thrown.\n\n        # Set the transaction to CANCELLED.\n        transaction.status = TransactionStatus.CANCELLED\n\n    async def create(\n        self,\n        amount: int,\n        pos: str,\n        currency: str = \"EUR\",\n        description: str | None = None,\n        reference: str | None = None,\n    ) -&gt; Transaction:\n        r\"\"\"\n        Method that registeres a Payment Request with Payconiq. The\n        caller should provide the `amount` _in EUROCENTS_, the identifier\n        of the Point of Sale (PoS) and currency. Note that, the currency\n        can only be EUR as of this time. In addition, an optinal transaction\n        description and reference can be provided. The reference is of\n        particular importance, as this corresponds to the banking reference\n        that will be injected in your transaction.\n        \"\"\"\n\n        assert all([amount &gt; 0, pos is not None, currency == \"EUR\"])\n\n        payload = {\n            \"amount\": amount,\n            \"currency\": currency,\n            \"posId\": pos,\n        }\n\n        if description:\n            payload[\"description\"] = description\n\n        if reference:\n            payload[\"reference\"] = reference\n\n        async with aiohttp.ClientSession() as session, session.post(\n            url=f\"{self._base}/v3/payments/pos\",\n            headers=self._headers,\n            json=payload,\n        ) as response:\n            assert response.status == 201  # Payment Request created.\n            return Transaction(\n                integration=self,\n                **await response.json(),\n            )\n</code></pre>"},{"location":"reference/pyconiq/integrations/static/#pyconiq.integrations.static.StaticIntegration.cancel","title":"<code>cancel(transaction)</code>  <code>async</code>","text":"<p>Cancels the specified transaction.</p> <p>Returns True on success, <code>False</code> otherwise.</p> Source code in <code>src/pyconiq/integrations/static.py</code> <pre><code>async def cancel(\n    self,\n    transaction: Transaction,\n) -&gt; None:\n    r\"\"\"\n    Cancels the specified transaction.\n\n    Returns True on success, `False` otherwise.\n    \"\"\"\n    endpoint = transaction.links.cancel\n    assert endpoint is not None\n\n    async with aiohttp.ClientSession() as session, session.delete(\n        url=endpoint,\n        headers=self._headers,\n    ) as response:\n        if not response.ok:\n            status = response.status\n            self._handle_api_error(\n                status=status,\n                payload=await response.json(),\n                transaction=transaction,\n            )\n            # Note, this line won't be reached as an exception will be thrown.\n\n    # Set the transaction to CANCELLED.\n    transaction.status = TransactionStatus.CANCELLED\n</code></pre>"},{"location":"reference/pyconiq/integrations/static/#pyconiq.integrations.static.StaticIntegration.create","title":"<code>create(amount, pos, currency='EUR', description=None, reference=None)</code>  <code>async</code>","text":"<p>Method that registeres a Payment Request with Payconiq. The caller should provide the <code>amount</code> in EUROCENTS, the identifier of the Point of Sale (PoS) and currency. Note that, the currency can only be EUR as of this time. In addition, an optinal transaction description and reference can be provided. The reference is of particular importance, as this corresponds to the banking reference that will be injected in your transaction.</p> Source code in <code>src/pyconiq/integrations/static.py</code> <pre><code>async def create(\n    self,\n    amount: int,\n    pos: str,\n    currency: str = \"EUR\",\n    description: str | None = None,\n    reference: str | None = None,\n) -&gt; Transaction:\n    r\"\"\"\n    Method that registeres a Payment Request with Payconiq. The\n    caller should provide the `amount` _in EUROCENTS_, the identifier\n    of the Point of Sale (PoS) and currency. Note that, the currency\n    can only be EUR as of this time. In addition, an optinal transaction\n    description and reference can be provided. The reference is of\n    particular importance, as this corresponds to the banking reference\n    that will be injected in your transaction.\n    \"\"\"\n\n    assert all([amount &gt; 0, pos is not None, currency == \"EUR\"])\n\n    payload = {\n        \"amount\": amount,\n        \"currency\": currency,\n        \"posId\": pos,\n    }\n\n    if description:\n        payload[\"description\"] = description\n\n    if reference:\n        payload[\"reference\"] = reference\n\n    async with aiohttp.ClientSession() as session, session.post(\n        url=f\"{self._base}/v3/payments/pos\",\n        headers=self._headers,\n        json=payload,\n    ) as response:\n        assert response.status == 201  # Payment Request created.\n        return Transaction(\n            integration=self,\n            **await response.json(),\n        )\n</code></pre>"}]}